
```c
__attribute__((aligned(n)))     // 采用 n 字节对齐
__attribute__((packed))         // 采用 1 字节对齐
```

- \_\_attribute__((aligned(n))) 中，n 的有效参数为 2 的幂值，32 位最大为 2^32，64 位为 2^64，这个时候编译器会将**让 n 与默认的对齐字节数进行比较，取较大值为对齐字节数，与 #pragma pack(n) 恰好相反。**
- \_\_attribute__((packed)) 则为**取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，也就是采用 1 字节对齐。**

> 注意，在64位操作系统64位编译器的环境下，当 n >= 8 时，内存对齐的字节数是 n，不然为 8；在32位操作系统32位编译器的环境下，当 n >= 4 时，内存对齐的字节数是 n，不然为 4。


```c
__alignof(type) //__alignof 操作返回数据类型或指定数据项的分界对齐值，type 为数据类型，如 char, double, int...
```

修饰变量：

C/C++ 中长度为 n 字节的基本数据类型的变量在编译时会被编译器默认分配到 n 字节对齐的内存上。例如，int 的长度是4字节，所以 int 类型变量将被分配到4字节对齐的地址上。我们也可以通过 \_\_attribute__((aligned(n)))来改变这种默认状态。如下：

```c
int a __attribute__ ((aligned (16))) = 0;
```

这样就把 a 分配到了16字节对齐的地址上。

修饰函数也是同样的道理。


示例(在64位系统64位编译器下测试)：

```c
struct A {
    int a;      //自身长4，aligned(2)对齐，编译器64位(8字节)，三者取最大值，所以为8字节对齐，放在[0,3]偏移的位置
    double b;   //自身长8，aligned(2)对齐，编译器8字节对齐，三者取最大值，所以为8字节对齐，放在[8,15]
    char c;     //身长1，aligned(2)对齐，编译器8字节对齐，三者取最大值，所以为8字节对齐，放在[16]
} __attribute__((aligned(2)));

//又因为整个结构体也需要8字节对齐，所以最终 sizeof(A) = 24
```

```c
struct A {
    int a;      //自身长4，aligned(8)对齐，编译器64位(8字节)，三者取最大值，所以为8字节对齐，放在[0,3]偏移的位置
    double b;   //自身长8，aligned(8)对齐，编译器8字节对齐，三者取最大值，所以为8字节对齐，放在[8,15]
    char c;     //身长1，aligned(8)对齐，编译器8字节对齐，三者取最大值，所以为8字节对齐，放在[16]
} __attribute__((aligned(8)));

//又因为整个结构体也需要8字节对齐，所以最终 sizeof(A) = 24
```

下面这个例子在64位系统64位编译器下测试与自己的想法不同：(下面是我理解的理论值)

```c
struct A {
    int a;      //自身长4，aligned(16)对齐，编译器64位(8字节)，三者取最大值，所以为16字节对齐，放在[0,3]偏移的位置
    double b;   //自身长8，aligned(16)对齐，编译器8字节对齐，三者取最大值，所以为16字节对齐，放在[16,23]
    char c;     //自身长1，aligned(16)对齐，编译器8字节对齐，三者取最大值，所以为16字节对齐，放在[32]，因为 32%16=0
} __attribute__((aligned(16)));

//又因为整个结构体也需要16字节对齐，所以最终 sizeof(A) = 48
```

但实际计算出的结果 sizeof(A) = 32。查看内存地址，发现成员变量 a, b, c 的实际内存地址如下：

> a 占4字节，地址为[0,3], 然后 [4,7] 这4个字节保留
>
> b 占8字节，地址为[8,15]
>
> c 占1字节，地址为[16]，然后 [17,31] 这15个字节保留，所以整个结构体占 32 字节。

无法理解的是，明明都 aligned(16) 了，A.b 的起始地址为什么没有对齐到16的整数倍？？？而是让整个结构体对齐到16的整数倍。

但实事如此，还是总结一下：

> 针对结构体而言，无论 aligned(n) 中的 n 是否大于编译器的字节数，结构体中的成员全部按照编译器的字节数对齐(32位的编译器，那就是4字节对齐；64位的编译器，那就是8字节对齐)，但整个结构体占用的字节数是按照 n 对齐的；

