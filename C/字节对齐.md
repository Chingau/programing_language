# 1. 什么是字节对齐
一个基本类型的变量在内存中占有 n 个字节，则该变量的起始地址必须能够被 n 整除，即**起始地址 % n == 0**，那么，就称该变量是字节对齐的；对于结构体、联合体而言，这个 n 取其所有基本类型成员中占用空间字节数最大的那个。

内存空间是以字节为基本单位进行划分的，从理论上讲，似乎对任何类型的变量的访问都可以从任何地址处开始，但实际情况是在访问特定类型变量的时候经常是从特定的内存地址处开始访问，这就需要各种类型的数据只能按照一定的规则在空间上排列，而不是顺序的一个接一个的排放；究其原因，是为了使不同架构的 CPU 可以提高访问内存的速度，就规定了对于特定类型的数据只能从特定的内存位置处开始访问；所以，各种类型的数据只能按照相应的规则在内存空间上排放，而不能顺序地、连续地、一个一个地排放；这就是内存对齐。

# 2. 为什么需要字节对齐
由于各种硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某个特定的内存地址处开始访问；比如，有些架构的 CPU 在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程就必须保证字节对齐；其它平台可能没有这种情况，但最常见的是，如果不按照适合其平台要求对数据进行对齐，会在存取效率上带来损失；比如，有些平台每次读取数据都是从偶地址处开始，如果一个 int(假设为32位系统)型数据从偶地址处开始存放，那么只需要一个读指令周期就可以完全读出这个 32bit 的 int 型数据，相反，如果这个 32bit 的 int 型数据是从奇地址处开始存放，那就需要两个读指令周期才能完全读出这个数据，并且还需要对这两次读取的结果的高低字节进行重新拼凑才能得到正确的 32bit 数据，这个时候，CPU 的读取效率明显下降。

# 3. 字节对齐规则
预处理指令 #pragma pack(align_value) 用于指定对齐值，而预处理指令 #pragma pack() 用于取消上次设定的对齐值，恢复默认的对齐值。

字节对齐是针对基本类型变量的；基本类型变量有：`char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, float, double` 等等；所以，对于结构体的对齐也只能按照其成员变量中的基本类型来对齐。

有四个概念需要理解：

- A、数据类型自身的对齐值

是指对该类型使用 sizeof() 操作符进行操作所得到的大小(单位：字节)，比如，对于 unsigned char 类型的数据，其自身对齐值为 1 字节。

- B、结构体、联合体、类的自身对齐值

是指其所有基本类型的成员中，自身对齐值最大的那个值，如果这些复合类型中有嵌套类型或复合类型的变量，则需要把这些嵌套的类型或复合类型的变量拆解成基本类型的成员之后再对齐。

- C、指定对齐值

是指使用预处理指令 #pragma pack(align_value) 指定的对齐值 align_value。

- D、数据成员、结构体和类的有效对齐值

是指其自身对齐值和指定对齐值中较小的那个值。

其中，有效对齐值是最终用来决定数据存放地址方式的值，最重要；**设定有效对齐值为 N，就表示"对齐在 N 字节上"，也就是说，该数据的 存放起始地址 % N == 0**。

因此,每个类型的数据的有效对齐值就是其自身对齐值(通常是这个类型的大小)和指定对齐值(不指定则取默认值)中较小的那个值，并且结构体自身对齐值是其所有成员中自身对齐值最大的那个值;

> 字节对齐的细节与编译器的实现有关,但一般来说,结构体需要满足以下几个准则:
>
> 1). 从结构体外部来看，结构体变量的首地址能够被其最宽基本成员的大小整除；从结构体内部来看，它的第一个数据成员的地址相对于整个结构体首地址的偏移量为0，也就是说，结构体的第一个数据成员存放在偏移量为 0 的地方;
>
> 2). 结构体中的每个数据成员的有效对齐值都取其自身对齐值和指定对齐值中的较小的那个对齐值；或者说是，结构体中的每个数据成员相对于结构体首地址的偏移量都是该数据成员大小和指定对齐值中较小的那个值(或有效对齐值)的整数倍，如有需要，编译器会在数据成员之间加上填充字节;
>
> 3). 如果结构体中还有嵌套的结构体或结构体变量，那么就要把这些嵌套进去的结构体或结构体变量拆成基本类型成员，并取其最长的基本类型成员的对齐方式；
>
> 4). 结构体整体的有效对齐值必须为其最宽基本类型成员大小的整数倍；或者说是，结构体整体的大小为结构体中最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节；换句话说是，结构体整体的有效对齐值按照结构体中最宽基本类型成员的大小和指定对齐值中较小的那个值进行；
>
> **注意:如果指定对齐值大于自身对齐值，则指定对齐值无效;**

# 4. 示例
例1：不带嵌套的

```c
#pragma pack(4) //指定按照4字节对齐
struct TestA
{
  int   a;  //第一个成员,自身长4,#pragma pack(4),取较小值,按照4字节对齐,放在[0,3]偏移的位置;
  char  b;  //第二个成员,自身长1,#pragma pack(4),取较小值,按照1字节对齐,放在[4]偏移的位置;
  short c;  //第三个成员,自身长2,#pragma pack(4),取较小值,按照2字节对齐,偏移量必须是2的整数倍,故,存放在[6,7]偏移的位置;
  char  d;  //第四个成员,自身长1,#pragma pack(4),取较小值,按照1字节对齐,放在[8]偏移的位置;
};
#pragma pack() //取消4字节对齐,恢复默认对齐值;
```

因此，整个结构体占用的有效字节为9个字节；由于结构体整体的对齐值和大小是其最宽基本类型成员大小的整数倍，即：按照最宽基本类型成员大小和指定对齐值中较小的值对齐的；因为结构体最宽基本类型成员的大小是4字节，其有效对齐值也是4字节，而9字节按照4字节圆整的结果是12字节，所以，sizeof(TestA)=12；

```c
#pragma pack(2) //指定按照2字节对齐
struct TestA
{
  int   a;  //第一个成员,自身长4,#pragma pack(4),取较小值,按照2字节对齐,放在[0,3]偏移的位置;
  char  b;  //第二个成员,自身长1,#pragma pack(2),取较小值,按照1字节对齐,放在[4]偏移的位置;
  short c;  //第三个成员,自身长1,#pragma pack(2),取较小值,按照2字节对齐,偏移量必须是2的整数倍,故,存放在[6,7]偏移的位置;
  char  d;  //第四个成员,自身长1,#pragma pack(2),取较小值,按照1字节对齐,放在[8]偏移的位置;
};
#pragma pack() //取消4字节对齐,恢复默认对齐值;
```

可以看出，只是改变了一下结构体之间的对齐方式，从4字节对齐改为2字节对齐；结果就不一样了；
整个结构体所占用的有效字节数仍然是9字节，但是结构体整体的大小就变了，按照最宽基本类型成员大小和指定对齐值中较小的值对齐；结构体中最宽基本类型成员的大小事4字节，而指定对齐值是2字节对齐，取最小值2，所以最后整个结构体的大小就是9字节按照2字节圆整(取2的整数倍)，于是，sizeof(TestA)=10；

例2：带嵌套的

```c
#pragma pack(2)
struct A 
{ 
  char c;   //第一个成员,自身长1,#pragma pack(2),取较小值,按照1字节对齐,放在[0]偏移的位置;
  int  i;   //第二个成员,自身长4,#pragma pack(2),取较小值,按照2字节对齐,放在[2,5]偏移的位置;
}; 
struct B 
{ 
  char c1;      //第一个成员,自身长1,#pragma pack(2),取较小值,按照1字节对齐,放在[0]偏移的位置;
  struct A s;   //第二个成员,自身长6,#pragma pack(2),取较小值,按照2字节对齐,放在[2,7]偏移的位置;
  char c2;      //第三个成员,自身长1,#pragma pack(2),取较小值,按照1字节对齐,存放在[8]偏移的位置;
}; 
#pragma pack()
```

结构体 A 占用的有效字节数是6字节；结构体 A 整体的大小要取其最宽基本类型成员大小和指定对齐值中较小的那个值的整数倍，最宽基本类型成员大小为4字节，指定对齐值为2字节，所以，6取较小的值2字节的整数倍为6字节；最终，结构体 A 的大小为：sizeof(A)=6；

结构体 B 占用的有效字节数是9字节；结构体B整体的大小要取其最宽基本类型成员大小和指定对齐值中较小的那个值的整数倍，最宽基本类型成员大小为6字节，指定对齐值为2字节，所以，9取较小的值2字节的整数倍为10字节；最终，结构体B的大小为：sizeof(B)=10;

# 5. 总结
设置对齐方式有两种方法：

第一种方法：

> #pragma pack(n)，指定按照 n 字节对齐
> #pragma pack()，取消自定义的对齐值

第二种方法：

> __attribute__((aligned(n)))，让所作用的结构体成员对齐在 n 字节自然边界上；如果结构体中有成员的长度大于 n，则按照最大成员的长度来对齐；即，按照机器能允许该类型的最大长度来对齐，这个恰好与 #pragma pack(n) 指令相反。
>
> __attribute__((packed))，取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐，等价于指令 #pragma pack(1)，即按照1字节对齐。其中 n 的值为2的幂。



