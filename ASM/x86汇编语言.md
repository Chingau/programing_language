# 1. 寄存器
## 数据寄存器
AX, BX, CX, DX 通用寄存器，也是数据寄存器，它们为16位寄存器，可分割为两个8位寄存器，如下：

```
AX = AH + AL
BX = BH + BL
CX = CH + CL
DX = DH + DL
```

- cx 可以当 loop 指令的循环限制次数

## 地址寄存器
我们知道8086CPU的地址线宽度为20位，但寄存器为16位，为了能达到20位的寻址宽度，8086CPU提供了以下寻址方式：

内存地址表示方式为 **段地址寄存器:偏移地址寄存器**；其寻址的计算方式为 **段地址<<4 + 偏移地址**。

表示段地址寄存器有如下几个：

```
ds  :访问数据(数据段)，ds指向的是数据保存在内存中的地址
es  :也可以当数据段
ss  :栈段，ss指向的内存地址为栈地址，通常与sp组合，如 ss:sp
cs  :访问指令(代码段)，cs指向的是指令保存在内存中的地址，通常与ip组合，如 cs:ip
```

表示偏移地址寄存器有如下几个：

```
sp (栈段的偏移寄存器，栈顶指针)
bp (这个可以理解为栈底指针，用于记录函数的调用路径)
si
di
ip (代码段的偏移寄存器)
bx (数据须的偏移寄存器)
```

## 标志位寄存器

# CPU是如何区分指令和数据的？
其实，指令和数据在内存中是没有区别的； CPU 仅仅将 cs:ip 指向的内存单元中的内容当作指令。

指令的执行过程：

1. CPU从CS:IP所指向的内存单元读取指令，存放到指令缓存器中
2. IP = IP + 所读指令的长度，从而指向下一条指令
3. 执行指令缓存器中的内容，然后回到步骤1

# 2.指令
## mov
```
mov ax,5        ; ax = 0x0005
mov bl,al       ; bl = al
mov al,ds:[8]    ; 把ds寄存器指向的内存地址偏移8字节的位置的内容赋值给al，方括号[]代表取该偏移里的内容
mov ds:[1],ax    ;

mov bx,2
mov ax,ds:[bx]  ;与 mov ax,ds:[2]等价
```

## add/sub/inc
```
add ax,8        ; ax = ax + 0x08
sub ax,8        ; ax = ax - 0x08
inc ax          ; ax = ax + 1，它与 add ax,1 功能相同，但指令占用的字节数更少
```

## push/pop
push/pop指令只操作16位的数据，例如 push al 则是错误的指令。入栈和出栈都是把数据放入内存中或从内存中取出数据。

push 指令的执行步骤：先修改sp寄存器的数值，sp=sp-2, 然后将要保存的数据放到ss:sp所指向的栈地址处。

pop 指令的执行步骤：先取出ss:sp所指向的栈地址处内存中的数据，然后修改sp寄存器的数值，sp=sp+2

```
push        ; 入栈 
pop         ; 出栈
```

## 跳转指令
- jmp
jmp 是一条转移指令，本质上是修改 cs:ip 这两个寄存器的值，决定了 CPU 从哪里读取指令。

```
jmp cs:ip       ; jmp 2000:0 跳转到20000的地址处
jmp reg         ; reg是一个寄存器,它只修改的是ip的值
jmp 标号
```
![](images/Snipaste_2023-03-12_00-29-45.png)

![](images/Snipaste_2023-03-12_00-32-42.png)

- call

- ret

- loop
loop 也是一种跳转指令，只不过它是一次数限制的(即循环多少次)，其循环次是保存在 CX 寄存器中。loop的一般使用方法为：

```
loop 标号
```

loop 指令的步骤：先将cx=cx-1,然后判断cx是否为0,不为0则跳转到标号位置执行,等于0则执行后面的指令，相对于C语言中：

```c
while (--cx) {
    ...
}
```

# 3. 伪指令
伪指令仅仅是告诉编译器如何翻译，本身不是指令。

```
start :告诉编译器程序的入口地址；实际上编译器会根据start的地址去设置cs:ip寄存器的值。

assume cs:code,ds:data,ss:stack :告诉编译器下面代码中出现code的就是cs段，data的就是ds段，stack的就是ss段。

data segment    :告诉编译器数据段从这里开始，其中data就是由assume设置的名字
data ends       :告诉编译器数据段在这里结束

stack segment stack
stack ends

code segment
code ends

end     :end指令告诉编译器整个汇编程序到这里就结束了
```