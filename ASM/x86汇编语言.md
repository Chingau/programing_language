# 1. 寄存器
## 数据寄存器
AX, BX, CX, DX 通用寄存器，也是数据寄存器，它们为16位寄存器，可分割为两个8位寄存器，如下：

```
AX = AH + AL
BX = BH + BL
CX = CH + CL
DX = DH + DL
```

- cx 可以当 loop 指令的循环限制次数

## 地址寄存器
我们知道8086CPU的地址线宽度为20位，但寄存器为16位，为了能达到20位的寻址宽度，8086CPU提供了以下寻址方式：

内存地址表示方式为 **段地址寄存器:偏移地址寄存器**；其寻址的计算方式为 **段地址<<4 + 偏移地址**。

表示段地址寄存器有如下几个：

```
ds  :访问数据(数据段)，ds指向的是数据保存在内存中的地址
es  :也可以当数据段
ss  :栈段，ss指向的内存地址为栈地址，通常与sp组合，如 ss:sp
cs  :访问指令(代码段)，cs指向的是指令保存在内存中的地址，通常与ip组合，如 cs:ip
```

表示偏移地址寄存器有如下几个：

```
sp (栈段的偏移寄存器，栈顶指针)
bp (这个可以理解为栈底指针，用于记录函数的调用路径)
si
di
ip (代码段的偏移寄存器)
bx (数据须的偏移寄存器)
```

## 标志位寄存器

# CPU是如何区分指令和数据的？
其实，指令和数据在内存中是没有区别的； CPU 仅仅将 cs:ip 指向的内存单元中的内容当作指令。

指令的执行过程：

1. CPU从CS:IP所指向的内存单元读取指令，存放到指令缓存器中
2. IP = IP + 所读指令的长度，从而指向下一条指令
3. 执行指令缓存器中的内容，然后回到步骤1

# 2.指令
## mov
```
mov ax,5        ; ax = 0x0005
mov bl,al       ; bl = al
mov al,ds:[8]    ; 把ds寄存器指向的内存地址偏移8字节的位置的内容赋值给al，方括号[]代表取该偏移里的内容
mov ds:[1],ax    ;

mov bx,2
mov ax,ds:[bx]  ;与 mov ax,ds:[2]等价
mov ax,ds:[bx+si]
mov ax,ds:[bx+di]
```

## add/sub/inc
```
add ax,8        ; ax = ax + 0x08
sub ax,8        ; ax = ax - 0x08
inc ax          ; ax = ax + 1，它与 add ax,1 功能相同，但指令占用的字节数更少
```

## div
除法指令 div

```
除数：有8位和16位两种，放在寄存器或内存单元中
被除数：默认放在 AX 或者 AX 和 DX 中
       如果除数为8位，被除数则为16位，默认存放在AX中
       如果除数为16位，被除数则为32位，DX存放高16位，AX存放低16位
结果：如果除数8位，则AL存商，AH存余数
      如果除数为16位，则AX存商，DX存余数
```

例如：

```
mov ax,16   ;被除数（被除数一定是放在寄存器中）
mov bl,3    ;除数（除数可以在寄存器中，也可以在内存中，如ds:[0],使用byte ptr来控制宽度）
div bl      ; 16/3 商-al,余数-ah
```

下面是完整示例：

```
assume cs:code,ds:data,ss:stack

data segment
    db 3,0,16,0,0,0,0,0
data ends

stack segment stack
    dw 0,0,0,0
    dw 0,0,0,0
    dw 0,0,0,0
    dw 0,0,0,0
stack ends

code segment
start:
    mov ax,data
    mov ds,ax

    ;被除为16位，除数为8位
    mov ax,16
    div byte ptr ds:[0]     ;16/3 al存商 ah存余数

    ;被除数为32位，除数为16位
    mov ax,ds:[2]
    mov dx,ds:[4]
    mov bx,3
    div bx                  ;16/3 ax存商 dx存余数

    mov ax,4c00H    ;程序返回
    int 21H
code ends
end start
```

如何确定使用多少位除法，如 100001/100 因为被除数超过16位，所以需要采用16位除法，即除数100要当成16位；再如 1000/300，因为除数300超过8位，所以需要采用16位除法，即被除数1000要当成32位。

## and/or
```
and ax,bx       ;ax = ax&bx
or ax,bx        ;ax = ax|bx
```

## push/pop
push/pop指令只操作16位的数据，例如 push al 则是错误的指令。入栈和出栈都是把数据放入内存中或从内存中取出数据。

push 指令的执行步骤：先修改sp寄存器的数值，sp=sp-2, 然后将要保存的数据放到ss:sp所指向的栈地址处。

pop 指令的执行步骤：先取出ss:sp所指向的栈地址处内存中的数据，然后修改sp寄存器的数值，sp=sp+2

```
push        ; 入栈 
pop         ; 出栈
```

## 跳转指令
- jmp
jmp 是一条转移指令，本质上是修改 cs:ip 这两个寄存器的值，决定了 CPU 从哪里读取指令。

```
jmp cs:ip       ; jmp 2000:0 跳转到20000的地址处
jmp reg         ; reg是一个寄存器,它只修改的是ip的值
jmp 标号
```
![](images/Snipaste_2023-03-12_00-29-45.png)

![](images/Snipaste_2023-03-12_00-32-42.png)

- call

- ret

- loop
loop 也是一种跳转指令，只不过它是一次数限制的(即循环多少次)，其循环次是保存在 CX 寄存器中。loop的一般使用方法为：

```
loop 标号
```

loop 指令的步骤：先将cx=cx-1,然后判断cx是否为0,不为0则跳转到标号位置执行,等于0则执行后面的指令，相对于C语言中：

```c
while (--cx) {
    ...
}
```

# 3. 伪指令
伪指令仅仅是告诉编译器如何翻译，本身不是指令。

```
start :告诉编译器程序的入口地址；实际上编译器会根据start的地址去设置cs:ip寄存器的值。

assume cs:code,ds:data,ss:stack :告诉编译器下面代码中出现code的就是cs段，data的就是ds段，stack的就是ss段。

data segment    :告诉编译器数据段从这里开始，其中data就是由assume设置的名字
data ends       :告诉编译器数据段在这里结束

stack segment stack
stack ends

code segment
code ends

end     :end指令告诉编译器整个汇编程序到这里就结束了
```

下面是对上面伪指令的示例：

```
assume cs:code,ds:data,ss:stack

data segment    ;定义数据段
    dw 0123H,0456H,0789H,0abcH,0defH,0cbaH,0987H,0876H
data ends

stack segment stack  ;定义栈段
    dw 0,0,0,0,0,0,0,0
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:
    mov ax,data     ;设置数据段，即设置ds段
    mov ds,ax   

    mov ax,stack    ;设置栈段，即设置ss段
    mov ss,ax
    mov sp,32       ;设置栈容量

code ends
end start
```

# 4.其它关键字
## dw/db/dd
dw 全称为 define word 即用户自定义的字数据(双字节)，db 即用户自定义的字节数据。

定义方式如下：

```
dw 1,2,3,4,5,6,7,8
```

## word ptr/dword ptr/byte ptr
我们知道，我们可以通过寄存器来判断处理数据的宽度，如下：

```
mov ax,1    ;因为ax是16位的寄存器，所以这里的1就被翻译占用16位
mov al,1    ;因为al是8位的寄存器，所以这里的1就被翻译占用8位

mov ds:[0],1    ;请问这里的1到底是占8位还是占16位？为了说明这种情况就出现了 word ptr，如下
mov word ptr ds:[0],1   ;因为有word ptr的说明，所以这里的1占16位

;还可以有如下写法：
add word ptr ds:[0],20
inc word ptr ds:[0]
```

同理，dword ptr 占32位，即4字节；byte ptr 占1字节。

# 5.寻址方式
```
ds:[0]
ds:[bx]
ds:[bx+si]
ds:[bx+si+5]
ds:[si+5], ds:[di+5]
```